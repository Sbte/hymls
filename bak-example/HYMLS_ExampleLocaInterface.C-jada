#include "HYMLS_ExampleLocaInterface.H"

#include "HYMLS_Preconditioner.H"

#include "HYMLS_Solver.H"
#include "HYMLS_Tools.H"
#include "Teuchos_RCP.hpp"
#include "Teuchos_ParameterList.hpp"
#include "Teuchos_StrUtils.hpp"
#include "HYMLS_MatrixUtils.H"
#include "LOCA_Parameter_Vector.H"

#include "Epetra_Map.h"
#include "Epetra_Vector.h"
#include "Epetra_MpiComm.h"
#include "Epetra_CrsMatrix.h"



#include <iostream>
#include <iomanip>

#include "Teuchos_oblackholestream.hpp"
#include "Teuchos_StrUtils.hpp"
#include "Teuchos_StandardCatchMacros.hpp"
#include "Teuchos_XMLParameterListHelpers.hpp"
#include "Teuchos_ScalarTraits.hpp"

#include <BelosIMGSOrthoManager.hpp>

#include "AnasaziBasicEigenproblem.hpp"
#include "AnasaziEpetraAdapter.hpp"
#ifdef HAVE_PHIST
#include "AnasaziPhistSolMgr.hpp"
#undef PREFIX
#else
#include "AnasaziJacobiDavidsonSolMgr.hpp"
#include "AnasaziHymlsAdapter.hpp"
#endif


#include "Epetra_Util.h"
#include "Epetra_CrsMatrix.h"
#include "Epetra_SerialComm.h"
#include "Epetra_Vector.h"
#include "Epetra_MultiVector.h"
#include "Epetra_IntVector.h"

#include "EpetraExt_VectorIn.h"
#include "EpetraExt_VectorOut.h"
#include "EpetraExt_BlockMapOut.h"

#include "NOX_Epetra_MultiVector.H"
#include "LOCA_Parameter_Vector.H"
#include "LOCA_Parameter_SublistParser.H"

#include "NOX_Epetra_LinearSystem_Hymls.H"
//#include "GaleriExt_Utils.H"

#include "HYMLS_Tools.H"
#include "HYMLS_MatrixUtils.H"
#include "HYMLS_Solver.H"
#include "HYMLS_Preconditioner.H"

typedef int gidx_other_t;

namespace HYMLS {


//! Constructor
exampleLocaInterface::exampleLocaInterface(Teuchos::RCP<Epetra_Comm> comm,
                                           Teuchos::ParameterList& params,
                                           Teuchos::RCP<Teuchos::ParameterList> lsParams,
                                           Teuchos::RCP<Teuchos::ParameterList> sharedParams)
  :
  dim_(3),
  dof_(2),
  comm_(comm),
  precond_(Teuchos::null),
  pVector_(Teuchos::null),
  sharedParams_(sharedParams),
  lsParams_(lsParams)
{
  nx_ = params.get("nx", -1);
  ny_ = params.get("ny", nx_);
  nz_ = params.get("nz", nx_);

  if (nx_==-1)
  {
    Tools::Error("missing parameter \"nx\" in \"Model\" parameter list",__FILE__,__LINE__);
  }

  // create a 3D HYMLS-style cartesian mapi
  rowMap_=HYMLS::MatrixUtils::CreateMap(nx_,ny_,nz_,dof_, 0, *comm_);

  // create clone vector
  currentState_=Teuchos::rcp(new Epetra_Vector(*rowMap_));
 
  // right hand side
  // rhs_ = Teuchos::rcp(new Epetra_Vector(*rowMap_));
  // create the Jacobian pattern.
  // The pattern we assume is a 7-point Laplacian for u and v with a
  // diagonal and off diagonal coupling term and periodic boundary conditions in all three
  // space directiions.
  currentJac_=Teuchos::rcp(new Epetra_CrsMatrix(Copy,*rowMap_,6));//maximum 8 nonzero per row
  massMatrix_=Teuchos::rcp(new Epetra_CrsMatrix(Copy,*rowMap_,1));

  for (int i=0; i<massMatrix_->NumMyRows(); i++)
  {
    gidx_other_t gid = massMatrix_->GRID(i);
    double val=1.0;
    CHECK_ZERO(massMatrix_->InsertGlobalValues(gid,1,&val,&gid));
  }
  CHECK_ZERO(massMatrix_->FillComplete());

  // get initial model parameters
  Teuchos::ParameterList &pList=params.sublist("Starting Parameters");
  r1_=pList.get("r1",1.0);
  r2_=pList.get("r2",1.0);
  D_=pList.get("D",0.0);
  sigma_=pList.get("sigma",0.0);
  alpha_=pList.get("alpha",0.0);
  beta_=pList.get("beta",0.0);
  source_=pList.get("source",0.0);
 
 
  // get continuation parameters 
  cont_param_ = params.get("Parameter Name","Undefined"); 

     int length = nx_*ny_*nz_*dof_;
     float inisol[length];
      int i=0;
      char ac[1024];
      FILE *f=NULL;
      // std::string Eigvecfile = "eigenVec.txt";
         
      if((f=fopen("solution-2DW-reorder.txt","r"))==NULL)
       {
         std::cout << "can not open\n";
       }
      else
       {
        while(fgets(ac, 1024, f) != NULL)
         {
          
          fscanf(f,"%f",&inisol[i]); 
          i++;   
         }         
             
       }
       
  if (f) fclose(f);

  CHECK_ZERO(currentState_->PutScalar(0.0));
 // HYMLS::MatrixUtils::Random(*currentState_);//range is [-1,1]
  for (int i=0; i<nx_*ny_*nz_*dof_; i++)
  {
   // (*currentState_)[i] =((*currentState_)[i]);
    // (*currentState_)[i] = inisol[i];
     //cout << (*currentState_)[i] << endl;

  }
  
  computeJacobian(*currentState_,*currentJac_);

  if (lsParams!=Teuchos::null)
  {
    // set up HYMLS Parameter list
   Teuchos::RCP<Teuchos::ParameterList> hymlsParams
     = Teuchos::rcp(&(lsParams->sublist("HYMLS")), false);

    Teuchos::ParameterList& probList=hymlsParams->sublist("Problem");

    probList.set("nx",nx_);
    probList.set("ny",ny_);
    probList.set("nz",nz_);
    precond_ = Teuchos::rcp(new HYMLS::Preconditioner(currentJac_, hymlsParams));
  }
  else
  {
     precond_ = Teuchos::null;
  }

}

//! Destructor
exampleLocaInterface::~exampleLocaInterface()
{
  //handled by RCP's
}

//get vector of possible continuation parameters for LOCA
Teuchos::RCP<LOCA::ParameterVector> exampleLocaInterface::getParameterVector()
{

  if (pVector_==Teuchos::null)
  {
    pVector_ = Teuchos::rcp(new LOCA::ParameterVector());

    pVector_->addParameter("r1",r1_);
    pVector_->addParameter("r2",r2_);
    pVector_->addParameter("D",D_);
    pVector_->addParameter("sigma",sigma_);
    pVector_->addParameter("alpha",alpha_);
    pVector_->addParameter("beta",beta_);
    pVector_->addParameter("source",source_);

  }
  else
  {
/*
    pVector_->setParameter("r1",r1_);
    pVector_->setParameter("r2",r2_);
    pVector_->setParameter("D",D_);
    pVector_->setParameter("sigma",sigma_);
    pVector_->setParameter("alpha",alpha_);
    pVector_->setParameter("beta",beta_);
*/
  }
  return pVector_;
}

  //! Compute the function, F, given the specified input vector x.  Returns true if computation was successful.
  bool exampleLocaInterface::computeF(const Epetra_Vector& x, Epetra_Vector& F,
                          const FillType fillFlag)
{
  double indl = nx_*nx_/900;
  double indr = nx_*nx_/900;
  double indu = nx_*nx_/900;
  double indd = nx_*nx_/900;
  double ind = nx_*nx_/900;
  gidx_other_t cols[6];
  double vals[6];
  cout << "r2=" << r2_ << endl;
 
int length = nx_*ny_*nz_*dof_;
     float Eigen[length];
      int i=0;
      char ac[1024];
      FILE *f=NULL;
      // std::string Eigvecfile = "eigenVec.txt";

      /*if((f=fopen("vec1.txt","r"))==NULL)
       {
         std::cout << "can not open\n";
       }
      else
       {
        while(fgets(ac, 1024, f) != NULL)
         {

          fscanf(f,"%f",&Eigen[i]);
          i++;
         }

       }

  if (f) fclose(f);*/


//  int row = 0; //count the row
  for (int k=0; k<nz_; k++)
  {
    for (int j=0; j<ny_; j++)
    {    
      for (int i=0; i<nx_; i++)
      {
        for (int var=0; var<2; var++)
        {
  //        row = row + 1;
          // diagonal element (row index)
          int ijk  = Tools::sub2ind(nx_,ny_,nz_,dof_,i,j,k,var);
          // coupling term to other variable
          int ijk2 = Tools::sub2ind(nx_,ny_,nz_,dof_,i,j,k,1-var);

          // 6 nearest neighbors
          int ip1=(i+1)%nx_,jp1=(j+1)%ny_,kp1=(k+1)%nz_;
          int im1=(i==0)?nx_-1:i-1,jm1=(j==0)?ny_-1:j-1, km1=(k==0)?nz_-1:k-1;

          int im1jk  = Tools::sub2ind(nx_,ny_,nz_,dof_,im1,j,k,var);
          int ip1jk  = Tools::sub2ind(nx_,ny_,nz_,dof_,ip1,j,k,var);
          int ijm1k  = Tools::sub2ind(nx_,ny_,nz_,dof_,i,jm1,k,var);
          int ijp1k  = Tools::sub2ind(nx_,ny_,nz_,dof_,i,jp1,k,var);
          //int ijkm1  = Tools::sub2ind(nx_,ny_,nz_,dof_,i,j,km1,var);
         // int ijkp1  = Tools::sub2ind(nx_,ny_,nz_,dof_,i,j,kp1,var);
          F[(gidx_other_t)ijk] = 0;
          int p=0;
   
          //Neumann boundary condition for the diffusion term 
         /* if(i==0)     indl = 0.0; 
          else indl = nx_*nx_;

          if(i==nx_-1) indr = 0.0;
          else indr = nx_*nx_;

          if(k==0)     indd = 0.0;
          else indd = nx_*nx_;

          if(k==nz_-1) indu = 0.0;
          else indu = nx_*nx_;*/

 /**************** ///  Below is the rhs of Interacting Turing System ************/
           if (var==0)
          {
            vals[p]=-D_*sigma_*4*ind+alpha_-alpha_*r1_*x[ijk2]*x[ijk2]-r2_*x[ijk2]; cols[p++]=(gidx_other_t)ijk;
            vals[p]=1;             cols[p++]=(gidx_other_t)ijk2;
            vals[p]=D_*sigma_*indl; cols[p++]=(gidx_other_t)im1jk;
            vals[p]=D_*sigma_*indr; cols[p++]=(gidx_other_t)ip1jk;
            vals[p]=D_*sigma_*ind; cols[p++]=(gidx_other_t)ijm1k;
            vals[p]=D_*sigma_*ind; cols[p++]=(gidx_other_t)ijp1k;
           // vals[p]=D_*sigma_*indd; cols[p++]=(gidx_other_t)ijkm1;
            //vals[p]=D_*sigma_*indu; cols[p++]=(gidx_other_t)ijkp1;                 

          }
          else
          {       
            vals[p]=-sigma_*4*ind+beta_+alpha_*r1_*x[ijk2]*x[ijk]+r2_*x[ijk2]; cols[p++]=(gidx_other_t)ijk;
            vals[p]=-alpha_;    cols[p++]=(gidx_other_t)ijk2;
            vals[p]=sigma_*indl; cols[p++]=(gidx_other_t)im1jk;
            vals[p]=sigma_*indr; cols[p++]=(gidx_other_t)ip1jk;
            vals[p]=sigma_*ind; cols[p++]=(gidx_other_t)ijm1k;
            vals[p]=sigma_*ind; cols[p++]=(gidx_other_t)ijp1k;
            //vals[p]=sigma_*indd; cols[p++]=(gidx_other_t)ijkm1;
            //vals[p]=sigma_*indu; cols[p++]=(gidx_other_t)ijkp1;
          }
 
/**************** ///  Below is the rhs of FitzHughâ€“Nagumo equation ************/
          /* if (var==0)
          {
            vals[p]=-D_*sigma_*4*ind+r1_-x[ijk]*x[ijk]; cols[p++]=(gidx_other_t)ijk;
            vals[p]=-1;             cols[p++]=(gidx_other_t)ijk2;
            vals[p]=D_*sigma_*ind; cols[p++]=(gidx_other_t)im1jk;
            vals[p]=D_*sigma_*ind; cols[p++]=(gidx_other_t)ip1jk;
            //vals[p]=D_*sigma_*ind; cols[p++]=(gidx_other_t)ijm1k;
            //vals[p]=D_*sigma_*ind; cols[p++]=(gidx_other_t)ijp1k;
            vals[p]=D_*sigma_*ind; cols[p++]=(gidx_other_t)ijkm1;
            vals[p]=D_*sigma_*ind; cols[p++]=(gidx_other_t)ijkp1;                 

          }
          else
          {       
            vals[p]=-sigma_*4*ind-1.0; cols[p++]=(gidx_other_t)ijk;
            vals[p]=1;    cols[p++]=(gidx_other_t)ijk2;
            vals[p]=sigma_*ind; cols[p++]=(gidx_other_t)im1jk;
            vals[p]=sigma_*ind; cols[p++]=(gidx_other_t)ip1jk;
            //vals[p]=sigma_*ind; cols[p++]=(gidx_other_t)ijm1k;
            //vals[p]=sigma_*ind; cols[p++]=(gidx_other_t)ijp1k;
            vals[p]=sigma_*ind; cols[p++]=(gidx_other_t)ijkm1;
            vals[p]=sigma_*ind; cols[p++]=(gidx_other_t)ijkp1;
          }*/
          
         
             
          for (int h=0; h<6; h++)
          {   
            F[(gidx_other_t)ijk]= F[(gidx_other_t)ijk] + vals[h]*x[cols[h]];
              
          }

       //F[(gidx_other_t)ijk] = F[(gidx_other_t)ijk] + Eigen[(gidx_other_t)ijk];
                    
        }
      }
    }
  }
   // set the phase condition, assume the average of u on the top line is zero for 2D. 
          F[nx_*2*nx_-2]=0.0;
  HYMLS::MatrixUtils::Dump(F,"rhs.txt");

  return true;
}


  /*! Compute Jacobian given the specified input vector x.  Returns
    true if computation was successful.
   */
  bool exampleLocaInterface::computeJacobian(const Epetra_Vector& x, Epetra_Operator& Jac)
  {
    return computeShiftedMatrix(1.0,0.0,x,Jac);
  }

      /*!
     * \brief Call user routine for computing the shifted matrix
     * \f$\alpha J + \beta M\f$ where \f$J\f$ is the Jacobian matrix
     * and \f$M\f$ is the mass matrix.
     */
bool exampleLocaInterface::computeShiftedMatrix(double alpha, double beta,
                const  Epetra_Vector& x,
                 Epetra_Operator& A)
{ 
  double indl = nx_*nx_/900.0;
  double indr = nx_*nx_/900.0;
  double indu = nx_*nx_/900.0;
  double indd = nx_*nx_/900.0;
  double ind = nx_*nx_/900.0;

  gidx_other_t cols[6];
  double vals[6];
  for (int k=0; k<nz_; k++)
  {
    for (int j=0; j<ny_; j++)
    {
      for (int i=0; i<nx_; i++)
      {
        for (int var=0; var<2; var++)
        {
          // diagonal element (row index)
          int ijk  = Tools::sub2ind(nx_,ny_,nz_,dof_,i,j,k,var);
          // coupling term to other variable
          int ijk2 = Tools::sub2ind(nx_,ny_,nz_,dof_,i,j,k,1-var);

          // 6 nearest neighbors
          int ip1=(i+1)%nx_,jp1=(j+1)%ny_,kp1=(k+1)%nz_;
          int im1=(i==0)?nx_-1:i-1,jm1=(j==0)?ny_-1:j-1, km1=(k==0)?nz_-1:k-1;

          int im1jk  = Tools::sub2ind(nx_,ny_,nz_,dof_,im1,j,k,var);
          int ip1jk  = Tools::sub2ind(nx_,ny_,nz_,dof_,ip1,j,k,var);
          int ijm1k  = Tools::sub2ind(nx_,ny_,nz_,dof_,i,jm1,k,var);
          int ijp1k  = Tools::sub2ind(nx_,ny_,nz_,dof_,i,jp1,k,var);
          //int ijkm1  = Tools::sub2ind(nx_,ny_,nz_,dof_,i,j,km1,var);
          //int ijkp1  = Tools::sub2ind(nx_,ny_,nz_,dof_,i,j,kp1,var);

          int p=0;
          //Neumann boundary condition for the diffusion term 
         /* if(i==0)     indl = 0.0; 
          else indl = nx_*nx_;

          if(i==nx_-1) indr = 0.0;
          else indr = nx_*nx_;

          if(k==0)     indd = 0.0;
          else indd = nx_*nx_;

          if(k==nz_-1) indu = 0.0;
          else indu = nx_*nx_;*/


/**************** ///  Below is the rhs of Interacting Turing System ************/
          if (var==0)
          {
            vals[p]=-D_*sigma_*4*ind+alpha_-alpha_*r1_*x[ijk2]*x[ijk2]-r2_*x[ijk2]; cols[p++]=(gidx_other_t)ijk;
            vals[p]=1-2*alpha_*r1_*x[ijk]*x[ijk2]-r2_*x[ijk]; cols[p++]=(gidx_other_t)ijk2;
            vals[p]=D_*sigma_*indl; cols[p++]=(gidx_other_t)im1jk;
            vals[p]=D_*sigma_*indr; cols[p++]=(gidx_other_t)ip1jk;
            vals[p]=D_*sigma_*ind; cols[p++]=(gidx_other_t)ijm1k;
            vals[p]=D_*sigma_*ind; cols[p++]=(gidx_other_t)ijp1k;
            //vals[p]=D_*sigma_*indd; cols[p++]=(gidx_other_t)ijkm1;
            //vals[p]=D_*sigma_*indu; cols[p++]=(gidx_other_t)ijkp1;
          }
          else
          {
            vals[p]=-sigma_*4*ind+beta_+2*alpha_*r1_*x[ijk2]*x[ijk]+r2_*x[ijk2]; cols[p++]=(gidx_other_t)ijk;
            vals[p]=-alpha_+alpha_*r1_*x[ijk]*x[ijk]+r2_*x[ijk]; cols[p++]=(gidx_other_t)ijk2;
            vals[p]=sigma_*indl; cols[p++]=(gidx_other_t)im1jk;
            vals[p]=sigma_*indr; cols[p++]=(gidx_other_t)ip1jk;
            vals[p]=sigma_*ind; cols[p++]=(gidx_other_t)ijm1k;
            vals[p]=sigma_*ind; cols[p++]=(gidx_other_t)ijp1k;
            //vals[p]=sigma_*indd; cols[p++]=(gidx_other_t)ijkm1;
            //vals[p]=sigma_*indu; cols[p++]=(gidx_other_t)ijkp1;
          }

/**************** ///  Below is the rhs of FitzHughâ€“Nagumo equation ************/
         /*if (var==0)
          {
            vals[p]=-D_*sigma_*4*ind+r1_-3*x[ijk]*x[ijk]; cols[p++]=(gidx_other_t)ijk;
            vals[p]=-1;             cols[p++]=(gidx_other_t)ijk2;
            vals[p]=D_*sigma_*ind; cols[p++]=(gidx_other_t)im1jk;
            vals[p]=D_*sigma_*ind; cols[p++]=(gidx_other_t)ip1jk;
            //vals[p]=D_*sigma_*ind; cols[p++]=(gidx_other_t)ijm1k;
            //vals[p]=D_*sigma_*ind; cols[p++]=(gidx_other_t)ijp1k;
            vals[p]=D_*sigma_*ind; cols[p++]=(gidx_other_t)ijkm1;
            vals[p]=D_*sigma_*ind; cols[p++]=(gidx_other_t)ijkp1;

          }
          else
          {
            vals[p]=-sigma_*4*ind-1.0; cols[p++]=(gidx_other_t)ijk;
            vals[p]=1;    cols[p++]=(gidx_other_t)ijk2;
            vals[p]=sigma_*ind; cols[p++]=(gidx_other_t)im1jk;
            vals[p]=sigma_*ind; cols[p++]=(gidx_other_t)ip1jk;
            //vals[p]=sigma_*ind; cols[p++]=(gidx_other_t)ijm1k;
            //vals[p]=sigma_*ind; cols[p++]=(gidx_other_t)ijp1k;
            vals[p]=sigma_*ind; cols[p++]=(gidx_other_t)ijkm1;
            vals[p]=sigma_*ind; cols[p++]=(gidx_other_t)ijkp1;
          }*/

          //set the phase condition
         if (ijk==nx_*nx_*2-2) 
            {
              vals[0]=1.0;
              vals[1]=0.0;
              vals[2]=0.0;
              vals[3]=0.0;
              vals[4]=0.0;
              vals[5]=0.0;
              //vals[6]=0.0;
             // vals[7]=0.0;

            }
   


          if (!currentJac_->Filled())
          {
            CHECK_ZERO(currentJac_->InsertGlobalValues((gidx_other_t)ijk,6,vals,cols));
          }
          else
          {
            CHECK_ZERO(currentJac_->ReplaceGlobalValues((gidx_other_t)ijk,6,vals,cols));
          }
        }
      }
    }
  }
  
  if (!currentJac_->Filled())
  {
    CHECK_ZERO(currentJac_->FillComplete());
  }
    HYMLS::MatrixUtils::Dump(*currentJac_,"jacMatrix.txt");
  return true; //TODO - put in correct values above
}


  /*//! Computes a user defined preconditioner.
  bool exampleLocaInterface::computePreconditioner(const Epetra_Vector& x,
                     Epetra_Operator& M,
                     Teuchos::ParameterList* precParams)
  {
    //TODO - in which situation does this function get a parameter list, and
    //       at which level?
    if (precParams!=NULL)
    {
      Tools::Warning("parameter list passed to computePreconditioner is ignored",__FILE__,__LINE__);
    }
    CHECK_ZERO(precond_->Compute());
    return true;
  }*/

 // compute preconditioner, which can then be retrieved by getPreconditioner()
bool exampleLocaInterface::computePreconditioner(const Epetra_Vector& x,
                                         Epetra_Operator& Prec,
                                         Teuchos::ParameterList* p)
  {
  // step_counter++;
  //if (step_counter>1) HYMLS::Tools::Error("STOP",__FILE__,__LINE__);
   int result=0;
  
  //DEBUG("enter LocaInterface::computePreconditioner");
  if (precond_ == Teuchos::null)
    {
   
    // no preconditioner parameters passed to constructor
    HYMLS::Tools::Error("No Preconditioner available!",__FILE__,__LINE__);
    }

  if (precond_->IsInitialized()==false)
    {
    CHECK_ZERO(result=precond_->Initialize());
    }

  if (result!=0)
    {
    HYMLS::Tools::Warning("Error code "+Teuchos::toString(result)+" returned when "+
                   " initializing the solver!",__FILE__,__LINE__);
    }


  if (result==0)
    {
    Teuchos::RCP<HYMLS::Preconditioner> hymls =
        Teuchos::rcp_dynamic_cast<HYMLS::Preconditioner>(precond_);
    result=precond_->Compute();
    if (result!=0)
      {
      HYMLS::Tools::Warning("Error code "+Teuchos::toString(result)+" returned when "+
                   " computing the solver!",__FILE__,__LINE__);
      }
    }

  DEBUG("leave LocaInterface::computePreconditioner");

  return (result==0);
  }


    /*!
      \brief Set parameters in the user's application.

      Should be called prior to calling one of the compute functions.
    */
    void exampleLocaInterface::setParameters(const LOCA::ParameterVector& p)
  {
    r1_ = p.getValue("r1");
    r2_ = p.getValue("r2");
    D_ = p.getValue("D");
    sigma_ = p.getValue("sigma");
    alpha_ = p.getValue("alpha");
    beta_ = p.getValue("beta");

  }


  int exampleLocaInterface::write_vector(const Epetra_Vector& vec, std::string filename)                                      
  {                                                                                                                   
    return HYMLS::MatrixUtils::mmwrite(filename,vec);                                                                   
  }                                                                                                                   
                                                                                                                      
// call fortran routine to read vector                                                                                
  int exampleLocaInterface::read_vector(Epetra_MultiVector& vec, std::string filename)                                        
  {                                                                                                                   
    return HYMLS::MatrixUtils::mmread(filename,vec);                                                                    
  }   
    //! Call user's own print routine for vector-parameter pair
  void exampleLocaInterface::printSolution(const Epetra_Vector& x,
                   double conParam)
   {
    int dump_psiome=0;
    //if (output_interval_>=0 || force_backup_)
     //{
    // if (conParam-last_output_>output_interval_ || force_backup_)
      //{i
      std::string paramName=Teuchos::StrUtils::varSubstitute(cont_param_," ","_");
      paramName=Teuchos::StrUtils::varSubstitute(paramName,"-","_");
      std::string filename =
       // "solution_"+paramName+"_"+Teuchos::toString((int)conParam)+".mtx";
       "solution_"+paramName+"_"+Teuchos::toString(conParam)+".mtx";
      this->write_vector(x, filename);
    //  this->write_state("restart.xml",filename);
      //last_output_=conParam;
//      force_backup_=false;
      dump_psiome=1;
      //}
    //}

   }
        /*!
          \brief Provides data to application for output files.

          This routine is called from Interface::xyzt::printSolution() just
          before the call to Interface::Required::printSolution(x,param),
          and gives the application some indices that can be used for
          creating a unique name/index for the output files.
        */
        void exampleLocaInterface::dataForPrintSolution(const int conStep, const int timeStep,
                                          const int totalTimeSteps)
  {
  }
 
    //! Perform any preprocessing before a continuation step starts.
    /*!
     * The \c stepStatus argument indicates whether the previous step was
     * successful.  The default implementation here is empty.
     */

   void
    exampleLocaInterface::preProcessContinuationStep(
                 LOCA::Abstract::Iterator::StepStatus stepStatus,
                 LOCA::Epetra::Group& group)
  {
    // do nothing right now
  }


    //! Perform any postprocessing after a continuation step finishes.
    /*!
     * The \c stepStatus argument indicates whether the step was
     * successful. The default implementation here is empty.
     */
    void
    exampleLocaInterface::postProcessContinuationStep(
                 LOCA::Abstract::Iterator::StepStatus stepStatus,
                 LOCA::Epetra::Group& group)
  {

    HYMLS::Tools::Out("post-process continuation step");
  // this function is a playground for doing some extra things
  // after each continuation step. The
  // code fragment below computes eigenvalues of inv(P)M, which
  // can be used as approximations of the eigs of [J,M] ner zero,
  // but it causes trouble and is not really needed.

  // Return if there were no iterations (restarted from a previous run)
  //if (!numNewtonIters_) return;

  typedef double ST;
  typedef Epetra_MultiVector MV;
  typedef Epetra_Operator OP;
  typedef HYMLS::Solver PREC;

  // note: we inherit globalData from LOCA's ModelEvaluatorInterface
  //LOCA::Parameter::SublistParser parsedParams(globalData_);
  //parsedParams.parseSublists(Teuchos::rcp(sharedParams_.get(),false));

   Teuchos::ParameterList &eigenParams =
    sharedParams_->sublist("LOCA").sublist("Stepper").sublist("Eigensolver");

  // We use "Default" here, because this is the only thing LOCA lets through.
  // In LOCA itself this method doesn't do anything.
  /*if (eigenParams.get("Method", "") != "Default")
     cout << "HELLO-Method" << endl;
    return;*/

  std::cout << *sharedParams_;
  std::cout << eigenParams;

  bool reuseBasis = eigenParams.get("Reuse Basis", true);
  Teuchos::RCP<Teuchos::ParameterList> hymlsList = Teuchos::rcp(
    new Teuchos::ParameterList(lsParams_->sublist("HYMLS")));

  if (eigenParams.isParameter("Linear Solve Iterations"))
    {
    hymlsList->sublist("Solver").sublist("Iterative Solver").set("Maximum Iterations",
        eigenParams.get("Linear Solve Iterations", -1));
    }

  // Recompute the preconditioner, because we want a good one for solving eigenvalues
  precond_->Compute();

  Teuchos::RCP<HYMLS::Solver> solver = Teuchos::rcp(new HYMLS::Solver(currentJac_, precond_, hymlsList, 1));
 // Teuchos::RCP<Epetra_CrsMatrix> mass = getMassMatrix();
  Teuchos::RCP<Epetra_MultiVector> x = Teuchos::rcp(new Epetra_Vector(*rowMap_));

  //HYMLS::MatrixUtils::Dump(*mass,"Mass.txt");
  double curParameter = group.getParam(0);
 if (reuseBasis && eigenVectors_ != Teuchos::null)
    {
    // Use a provided starting basis (previous eigenvectors)
    x = Teuchos::rcp(new Epetra_MultiVector(*eigenVectors_));

    }
    else
    {
    // Use a random B-orthogonal starting vector
    Teuchos::RCP<MV> v0 = Teuchos::rcp(new Epetra_Vector(x->Map()));
    HYMLS::MatrixUtils::Random(*v0);

    for (int i = 0; i < v0->MyLength(); i++)
      {
      if (v0->Map().GID(i) % dof_ == dim_)
        {
        (*v0)[0][i] = 0.0;
        }
      }

    precond_->ApplyInverse(*v0, *x);

    // Make x B-orthogonal
    double result;
    massMatrix_->Multiply(false, *x, *v0);
    x->Dot(*v0, &result);
    x->Scale(1.0/sqrt(result));
    }

  //prevParameter_ = curParameter;

  int numEigs = eigenParams.get("How Many", 2);

  Teuchos::RCP<Anasazi::BasicEigenproblem<ST, MV, OP> > eigProblem;
  eigProblem = Teuchos::rcp( new Anasazi::BasicEigenproblem<ST,MV,OP>(currentJac_, massMatrix_, x) );
  eigProblem->setHermitian(false);
  eigProblem->setNEV(numEigs);

  if (!eigProblem->setProblem())
    {
    HYMLS::Tools::Error("eigProblem->setProblem returned 'false'",__FILE__,__LINE__);
    }
#ifdef HAVE_PHIST
  std::cout << "We are using PHIST" << std::endl;
  Anasazi::PhistSolMgr<ST,MV,OP,PREC> jada(eigProblem, solver, eigenParams);
#else
  std::cout << "We are NOT using PHIST" << std::endl;
  Anasazi::JacobiDavidsonSolMgr<ST,MV,OP,PREC> jada(eigProblem, solver, eigenParams);
#endif

  // Solve the problem to the specified tolerances or length
  DEBUG("solve eigenproblem");
  Anasazi::ReturnType returnCode;
  returnCode = jada.solve();
  if (returnCode != Anasazi::Converged)
    {
    HYMLS::Tools::Warning("Anasazi::EigensolverMgr::solve() returned unconverged.",
      __FILE__,__LINE__);
    }

  DEBUG("post-process returned solution");
  const Anasazi::Eigensolution<ST,MV>& eigSol =
    eigProblem->getSolution();

  const std::vector<Anasazi::Value<ST> >& evals = eigSol.Evals;
  numEigs = (int)evals.size();

  // Output computed eigenvalues and their direct residuals
  HYMLS::Tools::out()<<std::endl<< "Computed Ritz Values"<< std::endl;
  HYMLS::Tools::out()<< std::setw(20) << "Real Part"
                     << std::setw(20) << "Imag Part"
                     << std::endl;
  HYMLS::Tools::out()<<"-----------------------------------------------------------"<<std::endl;
  for (int i=0; i<numEigs; i++)
    {
    HYMLS::Tools::out()<< std::setw(20) << evals[i].realpart
                       << std::setw(20) << evals[i].imagpart
                       << std::endl;
    }
  HYMLS::Tools::out()<<"-----------------------------------------------------------"<<std::endl;

  eigenVectors_ = eigSol.Espace;

  return;
  if (!ownEigStrat_) return;

  bool status=true;
  try {
    Teuchos::RCP<const NOX::Epetra::LinearSystem> linSys =
      group.getLinearSystem();

    Teuchos::RCP<const NOX::Epetra::LinearSystemHymls> hymlSys
      = Teuchos::rcp_dynamic_cast<const NOX::Epetra::LinearSystemHymls>(linSys);

    if (hymlSys==Teuchos::null)
{
      HYMLS::Tools::Warning("no HYMLS - no Eigs!", __FILE__, __LINE__);
      return;
      }
    Teuchos::RCP<HYMLS::Solver> hymls = hymlSys->getHymls();

    HYMLS::Tools::Out("============================");
    HYMLS::Tools::Out("HYMLS: estimate eigenvalues ");
    HYMLS::Tools::Out("============================");

    Teuchos::RCP<HYMLS::MatrixUtils::Eigensolution> precEigs
      = hymls->EigsPrec(10);

    // just print them to the default stream for now:
    HYMLS::Tools::Out("computed Eigenvalues of inv(P):");
    for (unsigned int i=0;i<precEigs->Evals.size();i++)
      {
      DEBUG(precEigs->Evals[i].realpart << "\t"<<precEigs->Evals[i].imagpart);
      }
    // now, depending on the eigenvalue estimates, we would like to do a more
    // detailed eigenvalue computation using e.g. Jacobi-Davidson on the updated
    // Jacobian and preconditioner. The eigenspace of P found so far could be
    // put to use, e.g. for choosing shifts and starting vectors.
    } TEUCHOS_STANDARD_CATCH_STATEMENTS(true,std::cerr,status);
  if (status==false)
    {
    HYMLS::Tools::Warning("caught an exception while computing prec eigs",__FILE__,__LINE__);
    }
  //HYMLS::MatrixUtils::Dump(*(eigs->Espace),"EigenBasis.txt");
  return;
  }


 
// This function is called after LOCA/Anasazi computes eigenvalues
// at the end of a continuation step to store the eigenpairs in some
// way. We use this occasion to adjust the Cayley parameters for the
// next step if "Adaptive Cayley" is set in the "Model" sublist.
/*NOX::Abstract::Group::ReturnType
LocaInterface::save(Teuchos::RCP< std::vector<double> >& evals_r,
  Teuchos::RCP< std::vector<double> >& evals_i,
  Teuchos::RCP< NOX::Abstract::MultiVector >& evecs_r,
  Teuchos::RCP< NOX::Abstract::MultiVector >& evecs_i)
  {
  HYMLS_PROF2(label_,"save eigs");
  if (comm_->MyPID()==0)
    {
    std::ofstream ofs("Eigenvalues.txt",std::ios::app);
    ofs << std::scientific << std::setw(8) << std::setprecision(8);

    ofs << "***************************************************"<<std::endl;
    ofs << "* Parameters                                      *"<<std::endl;
    ofs << "***************************************************"<<std::endl;
    for (int i=0;i<p_names_->size();i++)
      {
      ofs << (*p_names_)[i] << "\t" << (*p_values_)[i] << std::endl;
      }
    ofs << "***************************************************"<<std::endl;
    ofs << "* Eigenvalues                                     *"<<std::endl;
    ofs << "***************************************************"<<std::endl;
    for (int i=0;i<evals_r->size();i++)
      {
      ofs << (*evals_r)[i] << " + " << (*evals_i)[i]<<"i"<<std::endl;
      }
    ofs << "***************************************************"<<std::endl;

    ofs.close();
    }

  // to avoid huge text files we overwrite the eigenvectors every time
  const NOX::Epetra::MultiVector& evrNOXEpetra =
    dynamic_cast<const NOX::Epetra::MultiVector&>(*evecs_r);
  const Epetra_MultiVector& evr = evrNOXEpetra.getEpetraMultiVector();

  const NOX::Epetra::MultiVector& eviNOXEpetra =
    dynamic_cast<const NOX::Epetra::MultiVector&>(*evecs_i);
  const Epetra_MultiVector& evi = eviNOXEpetra.getEpetraMultiVector();

  HYMLS::MatrixUtils::Dump(evr,"eigenVectors_re.txt");
  HYMLS::MatrixUtils::Dump(evi,"eigenVectors_im.txt");

  if (ownEigStrat_)
    {
    if (sharedParams_==Teuchos::null)
      {
      HYMLS::Tools::Error("cannot proceed, shared param list not set\n"
        "You have to call setSharedData() in main program\n",
        __FILE__,__LINE__);
      }

    // note: we inherit globalData from LOCA's ModelEvaluatorInterface
    LOCA::Parameter::SublistParser parsedParams(globalData);
    parsedParams.parseSublists(Teuchos::rcp(sharedParams_.get(),false));

    Teuchos::RCP<Teuchos::ParameterList> eigenParams =
      parsedParams.getSublist("Eigensolver");
    string opType=eigenParams->get("Operator","Cayley");
    if (opType!="Cayley")
      {
      HYMLS::Tools::Error("'Adaptive Cayley' set with 'Operator' not 'Cayley'\n"
        "but '"+opType+"'",
        __FILE__,__LINE__);
      }
    HYMLS::Tools::Out("***************************************************");
    HYMLS::Tools::Out("* Adaptive Cayley strategy                        *");
    HYMLS::Tools::Out("***************************************************");
    // the transformed operator is defined as (A-sigma B)\(A-mu B), where
    // sigma is the 'Cayley Pole' and mu the 'Cayley Zero'. Our strategy
    // is to choose the centerline c between the two such that k eigenvalues
    // are between c and 0. Those eigenvalues are mapped to positions outside
    // the unit circle and will converge quickly in the next continuation step.
    double cayleyPole = eigenParams->get("Cayley Pole",0.0);
    double cayleyZero = eigenParams->get("Cayley Zero",-1.0);
    int numEigs = eigenParams->get("Num of Eigenvalues",10);
    HYMLS::Tools::out() << "current Cayley pole: "<<cayleyPole<<std::endl;
    HYMLS::Tools::out() << "current Cayley zero: "<<cayleyZero<<std::endl;

    HYMLS::Tools::Out("---------------------------------------------------");
    HYMLS::Tools::Out("| Current Eigenvalues                             |");
    HYMLS::Tools::Out("---------------------------------------------------");
    for (int i=0;i<evals_r->size();i++)
      {
      HYMLS::Tools::out() << (*evals_r)[i] << " + " << (*evals_i)[i]<<"i"<<std::endl;
      }
    HYMLS::Tools::Out("---------------------------------------------------");

    // select new shifts so that k eigenvalues are between c and 0.
    double c = 0.0;
    int count=0;
    double max_im=-1.0e99;
    double max_neg_re=-1.0e99;
    double min_re=1.0e99;
    for (int i=0;i<evals_r->size();i++)
      {
      if ((*evals_r)[i]<0.0)
        {
        max_neg_re=std::max(max_neg_re,(*evals_r)[i]);
        max_im=std::max(max_im,(*evals_i)[i]);
        }
      min_re = std::min(min_re,(*evals_r)[i]);
      }
    HYMLS::Tools::out() <<"smallest real part: "<<min_re<<std::endl;
    HYMLS::Tools::out() <<"largest neg. real part: "<<max_neg_re<<std::endl;
    HYMLS::Tools::out() <<"largest stable imaginary part: "<<max_im<<std::endl;

    cayleyPole = max_im;
    // We use the smallest computed eigenvalue as c,
    // where c is the centerline between sigma (pole) and mu (zero):
    //min_eig = (cayleyPole+cayleyZero)/2;
    cayleyZero=2.0*min_re-cayleyPole;

    if (numEigs<evals_r->size())
      {
      HYMLS::Tools::Out(" increase search range because not all eigs converged.");
      cayleyZero*=1.25;
      }

    HYMLS::Tools::out() <<"new Cayley pole: "<<cayleyPole<<std::endl;
    HYMLS::Tools::out() <<"new Cayley zero: "<<cayleyZero<<std::endl;
    HYMLS::Tools::Out("***************************************************");

    eigenParams->set("Cayley Pole",cayleyPole);
    eigenParams->set("Cayley Zero",cayleyZero);
    }

  return NOX::Abstract::Group::Ok;
  }*/

    /*!
      \brief Projects solution to a few scalars for
      multiparameter continuation

      Default implementation is the max norm.
    */
    void exampleLocaInterface::projectToDraw(const NOX::Epetra::Vector& x,
                   double *px) const {
      // use default implementation for now
      px[0] = x.norm(NOX::Abstract::Vector::MaxNorm);
    }

    //! Returns the dimension of the projection to draw array
    int exampleLocaInterface::projectToDrawDimension() const { return 1; }


  } // HYMLS
